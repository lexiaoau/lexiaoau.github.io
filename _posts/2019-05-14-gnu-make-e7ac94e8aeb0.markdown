---
author: lexiao
comments: true
date: 2019-05-14 01:36:11+00:00
layout: post
link: http://localhost/blog/?p=376
slug: gnu-make-%e7%ac%94%e8%ae%b0
title: GNU make 笔记
wordpress_id: 376
categories:
- 默认分类
---

 
  1. 基本概念
   
    1. _target --- _usually the name of a file that is generated by a program
 
    2. _prerequisite_ ---- file that is used as input to create the target
 
    3. _recipe_ --- an action that make carries out. A recipe may have more than one command
 
    4. _rule --- _explains how and when to remake certain files which are the targets of the particular rule. `make` carries out the recipe on the prerequisites to create or update the target. A rule can also explain how and when to carry out an action.
 
  2. 基本规定和语法
   
    1. put a tab character at the beginning of every recipe line!
  3. make 中的条件判断
    1. 条件语句可以_根据一个变量的值来控制make执行或者忽略Makefile的特定部分_。条件语句可以是_两个不同变量、或者变量和常量值的比较_。要注意的是：条件语句只能用于控制make实际执行的makefile文件部分，它不能控制规则的shell命令执行过程。
    2. 条件判断语法：
      1. **CONDITIONAL-DIRECTIVE**  
TEXT-IF-TRUE  
[ **else**  
TEXT-IF-FALSE ]  
**endif**
      2. 条件判断符（CONDITIONAL-DIRECTIVE）
        1. ifeq
          1. 如果两个变量相等时为真
          2. 格式：
            1. ifeq (arg1, arg2)  
ifeq 'arg1' 'arg2'  
ifeq "arg1" "arg2"  
ifeq "arg1" 'arg2'  
ifeq 'arg1' "arg2"
            2. 即是不区分单引号，双引号
        2. ifneq
          1. 如果两个变量相等时为真
          2. 格式：同 ifeq
        3. ifdef
          1. 如果变量“VAEIABLE_NAME”的值非空（在Makefile中没有定义的变量的值为空），那么表达式为真
          2. 格式：
            1. ifdef variable-name
        4. ifndef
          1. 如果变量“VAEIABLE_NAME”的值为空（在Makefile中没有定义的变量的值为空），那么表达式为真
          2. 格式：
            1. ifndef _variable-name_
            2. 条件判断例子：
            3. ifeq ($(CC),gcc)  
$(CC) -o foo $(objects) $(libs_for_gcc)  
else  
$(CC) -o foo $(objects) $(normal_libs)  
endif
            4. ifeq ($(CC),gcc)  
libs=$(libs_for_gcc)  
else  
libs=$(normal_libs)  
endif
            5. ifeq ($(strip $(foo)),) #先去除变量前后的空格再进行比较，然后判断是否为空字符  
TEXT-IF-EMPTY  
endif
  4. 如何写rule
    1. 概念
      1. 规则描述了在何种情况下使用什么命令来重建一个特定的文件，此文件被称为规则“_目标_”（target）（通常规则中的目标只有一个）。
      2. 规则中除目标之外的罗列的其它文件称为“目标”的_依赖（prerequisites）_，而规则的_命令_（recipe）是用来更新或者创建此规则的目标。
      3. 除了终极目标外，其它规则的顺序是不重要的。终极目标指的是在第一个makefile中出现的第一个rule的目标。
        1. 有两个例外，第一种情况是目标名以点号“.”开始的并且其后不存在斜线“/”（“./”被认为是当前目录；“../”被认为是上一级目录） ；第二种情况是模式规则的目标。  

    2. 语法
      1. rule的一般语法
        1. targets : prerequisites  
recipe  
...
        2. 例子:
          1. foo.o : foo.c defs.h # module for twiddling the frobs  
cc -c -g foo.c
        3. 说明：
          1. 目标是文件名，用空格分隔；可以使用通配符。
          2. 命令行（recipe）要以tab开始，
          3. 一个长的行可以用backslash（\）分隔，
          4. 目标是否需要重build取决于依赖，如果目标文件不存在，或者目标文件的生成时间比依赖中的任何一个文件的修改时间早，那么需要重build。
          5. Maekfile中表示文件名时可使用通配符。可使用的通配符有：“*”、“?”和“[…]”。在Makefile中通配符的用法和含义和Linux（unix）的Bourne shell完全相同。通配符可以使用在规则的目标、依赖、命令中。$(wildcard *.c))
  5. 如何写命令中的规则
    1. 概念
      1. 规则的命令由一些shell命令行组成，它们被一条一条的执行。  

    2. 语法
  6. 变量
    1. 特殊变量
      1. $*              不包含扩展名的目标文件名称。<br>$+              所有的依赖文件，以空格分开，并以出现的先后为序，可能包含重复的依赖文件。<br>$<              第一个依赖文件的名称。<br>$?              所有的依赖文件，以空格分开，这些依赖文件的修改日期比目标的创建日期晚。<br>$@              目标的完整名称。<br>$^              所有的依赖文件，以空格分开，不包含重复的依赖文件。<br>$%              如果目标是归档成员，则该变量表示目标的归档成员名称。例如，如果目标名称<br>                为 mytarget.so(image.o)，则 $@ 为 mytarget.so，而 $% 为 image.o。

    2.   

