---
author: lexiao
comments: true
date: 2019-05-14 01:36:56+00:00
layout: post
link: http://localhost/blog/?p=420
slug: algorithmstl-%e7%ae%97%e6%b3%95%ef%bc%89
title: algorithm(STL 算法）
wordpress_id: 420
categories:
- C++
---



  1. 要使用算法，必须“#include <algorithm>”。



    1. 很多算术算法，需要 “#include <numeric>”。


    2. 使用某个算法，必须注意它对容器的要求。是否能应用到该容器及其所包含的类型中。


    3. 泛型算法本身 从不 执行 容器操作，只是依赖 迭代器 和 迭代器操作 实现。算法 还不会 直接添加或者删除元素。


  2. 只读算法



    1. accumulate 算法（算术算法） ————求一个范围的所有元素的和



      1. 格式为 accumulate( begin(), end(), 第三形参 ）


      2. 第三形参 是 用以指定 求和结果 的 类型，如果没有它，则编译器无法知道 结果 应该是什么类型。其值 将作为 加法 的起始值。


      3. （注意）容器内类型 必须是 与 第三形参 类型 相匹配的。


    2. find 算法



      1. 格式为 find( begin(), end(), 第三形参 ）


      2. 第三形参 是 用以指定 被查找的值。


      3. 如果在范围内找到该值，则 返回一个指向 该元素 的 iterator； 如果找不到，则返回 end（）


      4. （注意）要求 元素类型 定义了 （==） 操作符。


    3. count_if 算法



      1. 找出在一个范围内，有多少个 元素满足给定条件。


      2. 该算法 必须 给出 第三形参（函数），该函数接受一个参数，并且返回 bool值。算法根据返回值判断 该元素 是否满足给定条件。


  3. 写的算法



    1. fill 算法



      1. 将一个范围内的所有元素设成 指定值。


    2. copy算法



      1. 将一个范围内的元素 复制 到另一个容器中。


  4. 将一个元素移动给另外一个元素的算法



    1. sort 算法



      1. 根据 容器的 “<”操作符，对容器内一个范围内的元素排序。无返回值。


      2. 可以接受一个函数 作为 第三形参，这个函数 必须 接受两个参数，而且要返回一个 bool 值，指示对这两个参数比较的结果。如果 给出 第三形参，则在比较时，会把两个相邻元素 传给该函数去比较，然后根据返回值排序。


    2. stable_sort 算法



      1. 该算法 与 sort类似，唯一不同是，当两个相邻元素相等时，保持他们原顺序不变。


    3. unique 算法



      1. 对容器内所有元素重新排序，将无重复的元素排到容器的前面，将重复的元素放到容器后面，返回值是一个iterator，指向 “无重复” 与 “重复”之间。
